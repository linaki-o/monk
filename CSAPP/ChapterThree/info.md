# Machine-Level Representation of Programs
why should we spend our time learning machine code?
- By reading this code, we can understand the optimization capabilities of the compiler and analyze the underlying inefficiencies in the code

- get a sense of how efficiently the program will run

- there are times when the layer of abstraction provided by a high-level language hides information about the run-time behavior of a program that we need to understand

-  many of the ways programs can be attacked, allowing malware to infest a system, involve nuances of the way programs store their run-time control information

the machine language is starting with Intel Corporation’s first 16-bit processor in 1978
## A Historical Perspective

## Program Encodings

`linux> gcc -Og -o p p1.c p2.c`

The command-line option -Og instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code

higher levels of optimization (e.g., specified with the option -O1 or -O2) are considered a better choice in terms of the resulting program performance.

### Machine-Level Code

The machine code for x86-64 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer:
- The program counter (commonly referred to as the PC, and called %rip in x86- 64) indicates the address in memory of the next instruction to be executed.


Whereas C provides a model in which objects of different data types can be declared and allocated in memory, machine code views the memory as simply a large byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes.

The program memory contains the executable machine code for the program, some information required by the operating system, a run-time stack for managing procedure calls and returns, and blocks of memory allocated by the user


As mentioned earlier, the program memory is addressed using virtual addresses. At any given time, only limited subranges of virtual addresses are considered valid. For example, x86-64 virtual addresses are represented by 64-bit words. In current implementations of these machines, the upper 16 bits must be set to zero, and so an address can potentially specify a byte over a range of 248, or 64 terabytes.

### Code Examples
```
linux> gcc -Og -S mstore.c ==> mstore.s

linux> gcc -Og -c mstore.c ==> mstore.o

linux> objdump -d mstore.o ==> mstore.s
```
Several features about machine code and its disassembled representation are worth noting:
- x86-64 instructions can range in length from 1 to 15 bytes
- The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions
- The disassembler determines the assembly code based purely on the byte sequences in the machine-code file
- The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc

<img src="img/1.png">

lines 8–9 will have no effect on the program, since they occur after the return instruction (line 7). They have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms
of memory system performance

###  Notes on Formatting

All of the lines beginning with ‘.’ are directives to guide the assembler and
linker

In our presentation, we show assembly code in ATT format (named after AT&T, the company that operated Bell Laboratories for many years), the default format for gcc

use Inter format
```
linux> gcc -Og -S -masm=intel mstore.c
```

## Data Formats

Pointers (shown here as char *) are stored as 8-byte quad words, as would be expected in a 64-bit machine. 
<img src="img/dt.type">

`Microprocessors in the x86 family historically implemented all floating-point operations with a special 80-bit (10- byte) floating-point format (see Problem 2.86). This format can be specified in C programs using the declaration long double. We recommend against using this format, however. It is not portable to other classes of machines, and it is typically not implemented with the same high-performance hardware as is the case for single- and double-precision arithmetic`

## Accessing Information

<img src="img/16register.png">

When these instructions have registers as destinations, two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes: **Those that generate 1- or 2-byte quantities leave the remaining bytes unchanged. Those that generate 4- byte quantities set the upper 4 bytes of the register to zero. The latter convention was adopted as part of the expansion from IA32 to x86-64**

### Operand Specifiers
<img src="img/operand.png">
immediate, is for constant values: $-577 or $0x1F

The most general form: Imm(rb,ri,s) **has four components: an immediate offset Imm, a base register rb, an index register ri, and a scale factor s, where s must be 1, 2, 4, or 8. Both the base and index must be 64-bit registers.**  The effective address is computed as Imm + R[rb] + R[ri] * s

### Data Movement Instructions
<img src="img/mov.png">

**x86-64 imposes the restriction that a move instruction cannot have both operands refer to memory locations**

For most cases, the mov instructions will only update the specific register bytes or memory locations indicated by the destination operand. The only exception is that when movl has a register as the destination, it will also set the high-order 4 bytes of the register to 0.


movq %rax,-12(%rbp):
```
The regular movq instruction can only have immediate source operands that can be represented as 32-bit two’s-complement numbers. This value is then sign extended to produce the 64-bit value for the destination. The movabsq instruction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination
```
