# 宏命令
## 基本宏命令
宏命令的基本语法如下：
```
qa                     开始记录动作到寄存器 a
q (while recording)    停止记录
```
执行
```
@a    Execute macro from register a
@@    Execute the last executed macros
```
## 安全保护
在执行遇到错误的时候，宏命令会自动停止。

Vim 到达最后一行执行j时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。

## 命令行执行宏
在正常模式执行 @a 并不是宏命令调用的唯一方式。你也可以在命令行执行 ：normal @a 。：normal 会将任何用户添加的参数作为命令去执行。例如添加 @a，和在 normal mode 执行 @a 的效果是一样的。

:normal 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 ：2,3 normal @a。
## 在多个文件中执行宏命令
假如你有多个 .txt 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是0W~j(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？
- :args *.txt 查找当前目录下的所有 .txt 文件。
- :argdo g/donut/normal @a 在 :args 中包含的每一个文件里执行一个全局命令 g/donut/normal @a。
- :argdo update 在 :args 中包含的每一个文件里执行 update 命令,保存修改后的内容。

## 递归执行宏命令
```
qaqqa0W~j@aq
```
- qaq 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。
- qa 开始录入宏命令到寄存器 “a”。
- 0 移动到行首。
- W 移动到下一个单词。
- ~ 改变光标选中的单词的大小写。
- j 移动到下一行。
- @a 执行宏命令 “a”。当你记录该宏命令时，@a 应该是空白的，因为你刚刚调用了 qaq。
- q 停止记录。


宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 j 命令时，发现已经没有下一行了，就会停止执行。

## 增添一个已知宏
为了在寄存器"a"中添加更多的操作，你也可以使用大写字母"A"。
```
qAA.<esc>q
```
- qA 开始在寄存器 “A” 中记录宏命令。
- A.<esc> 在行的末尾加上一个句点(这里的A是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。
- q 停止记录宏命令。

## 修改一个已知宏

先用:put a 输出寄存器中已有的内容，然后修改，然后执行"ay$ 使用寄存器"a"来存储复制的文本

如何输出特定字符：在输入模式下按ctrl-v 然后再按需要的特定字符的特定键

另一个修改宏命令的方式是通过命令行表达式。执行 :let @a="，之后执行 Ctrl-r Ctrl-r a，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（"）

## 拷贝宏

你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 :let @z = @a 将寄存器"a" 中的命令拷贝到寄存器"z"。

## 串行宏和并行宏
可以使用 :normal 去执行宏命令，（例如： :3,5 normal @a 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 :1,$ normal @a，会在所有除了包含有 “foo” 的行执行，而且它不会出错。

尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（1,$）每一行执行 @a 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。